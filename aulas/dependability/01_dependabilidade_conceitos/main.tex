\documentclass{beamer}

\usetheme{Madrid}
\usecolortheme{beaver}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{array}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta, calc, fit, shapes.geometric}
\usepackage{tcolorbox}
\tcbuselibrary{skins, breakable}
\usepackage{listings}
\usepackage{hyperref}

\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  linkcolor=blue
}

\lstset{
  basicstyle=\ttfamily\small,
  columns=fullflexible,
  frame=single,
  breaklines=true
}

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Índice}
    \tableofcontents[currentsection]
  \end{frame}
}

% ----------------- Macros úteis (Aula 1: sem matemáticas pesadas) -----------------
\newcommand{\svc}{\textit{serviço}}
\newcommand{\spec}{\textit{especificação}}
\newcommand{\fail}{\textit{falha}}
\newcommand{\err}{\textit{erro de estado}}
\newcommand{\fault}{\textit{fault/defeito}}

\title[Dependabilidade (Aula 1)]{Dependabilidade em Software e Sistemas Computacionais\\\small (Aula 1: Serviço, Semântica de Falhas, Contenção e Recuperação)}
\author{Prof. Iaçanã Ianiski Weber}
\institute{PUCRS}
\date{CSS (98G08-4) -- Aula 1}

\begin{document}

% =============================== CAPA ===============================
\begin{frame}[plain]
\noindent
\begin{minipage}[t]{0.15\textwidth}
    \includegraphics[width=\linewidth]{../img/brasao_pucrs.png}
    % TODO: ajustar caminho do brasão, se necessário.
\end{minipage}%
\begin{minipage}[t]{0.75\textwidth}
    \begin{center}
        \raisebox{5ex}{\LARGE\bfseries\textcolor{blue}{\textbf{Dependabilidade}}}\\
        \raisebox{2ex}{\LARGE\bfseries\textcolor{blue}{Serviço, Falhas e Tolerância}}\\
    \end{center}
\end{minipage}

\vspace{1.6cm}

\begin{center}
    \Large \textbf{Prof. Dr. Iaçanã Ianiski Weber} \\
    \vspace{0.2cm}
    \normalsize \textit{Confiabilidade e Segurança de Software} \\
    \vspace{0.2cm}
    \large 98G08-4
\end{center}

\vfill
\begin{center}
\scriptsize
\textit{Escopo desta aula: “antes” de métricas (Aula 2) e “antes” de safety/security/resiliência (Aula 3).}
\end{center}
\end{frame}

\begin{frame}{Índice}
  \tableofcontents
\end{frame}

% =========================================================
\section{Escopo da disciplina: como os 3 decks se encaixam}

\begin{frame}{Mapa das 3 aulas (para evitar sobreposição)}
\centering
\begin{tikzpicture}[>=Stealth, node distance=8mm]
  \node[draw, rounded corners, align=center, minimum width=0.90\textwidth, fill=blue!6] (a1)
  {\textbf{Aula 1 (este deck)}\\
   \small Serviço \& Especificação $\rightarrow$ Semântica de falhas $\rightarrow$ Contenção/Detecção/Recuperação\\
   \small (ênfase em software + sistemas distribuídos + fronteiras/isolamento)
  };

  \node[draw, rounded corners, align=center, minimum width=0.90\textwidth, below=of a1, fill=green!6] (a2)
  {\textbf{Aula 2 (deck 2)}\\
   \small Confiabilidade e Disponibilidade: modelos probabilísticos, hazard, Weibull, composição (RBD/Markov), SLO/SLI
  };

  \node[draw, rounded corners, align=center, minimum width=0.90\textwidth, below=of a2, fill=red!6] (a3)
  {\textbf{Aula 3 (deck 3)}\\
   \small Safety, Security e Resiliência: hazard/risk, threat modeling, NIST CSF, STPA, cyber-resiliency, assurance
  };

  \draw[->, thick] (a1) -- (a2);
  \draw[->, thick] (a2) -- (a3);
\end{tikzpicture}

\vspace{0.4em}
\begin{block}{Mensagem}
Se você não define \textbf{qual é o serviço} e \textbf{qual semântica de falha} você tolera, as métricas (Aula 2) e os requisitos de safety/security (Aula 3) ficam “soltos”.
\end{block}

%% [AULA] Explicitar para a turma: “falha” é sempre relativa a uma especificação/contrato.
\end{frame}

\begin{frame}{Objetivos técnicos da Aula 1 (revisados)}
Ao final, o aluno deve conseguir:
\begin{itemize}
  \item Definir \textbf{serviço} e \textbf{especificação} e entender por que \textbf{falha} é desvio do contrato (não “bug”).
  \item Usar a cadeia \fault $\rightarrow$ \err $\rightarrow$ \fail, mas com foco em:
    \begin{itemize}
      \item \textbf{semântica de falhas} (crash/omission/timing/value/Byzantine),
      \item \textbf{semântica de execução} em RPC (at-least-once / at-most-once) e suas implicações.
    \end{itemize}
  \item Projetar \textbf{barreiras}: detecção, contenção (fault containment) e recuperação (restart/rollback/transação).
  \item Identificar armadilhas clássicas: retries amplificando incidentes, idempotência, causa comum, observabilidade insuficiente.
\end{itemize}

%% [AULA] Use um exemplo simples de API (ex.: “debitar saldo”) para motivar idempotência e deduplicação.
\end{frame}

% =========================================================
\section{Serviço, especificação e o que significa “falhar”}

\begin{frame}{Serviço é o que o mundo observa (e cobra)}
\begin{block}{Definição operacional}
\textbf{Serviço} (\svc) é o comportamento observável na interface com usuário/sistemas;\\
\textbf{Estado interno} pode estar errado (\err) e mesmo assim o serviço não falhar (mas isso é risco!).
\end{block}

\begin{itemize}
  \item A mesma implementação pode “falhar” ou “não falhar” dependendo da \spec:
    \begin{itemize}
      \item latência máxima (timing), valor correto (value), disponibilidade, consistência.
    \end{itemize}
  \item Em sistemas modernos, “falha” pode ser \textbf{parcial}:
    \begin{itemize}
      \item degradação (p99 explode), funcionalidade limitada, respostas inconsistentes.
    \end{itemize}
\end{itemize}

%% TALKING POINT: “estar up” não é “estar correto” (mas métricas detalhadas ficam para Aula 2).
\end{frame}

\begin{frame}{Contrato mínimo: pré/pós-condições e invariantes}
\begin{columns}[T,onlytextwidth]
\column{0.56\textwidth}
\begin{itemize}
  \item \textbf{Pré-condições}: o que precisa ser verdade antes da operação (inputs válidos, permissões).
  \item \textbf{Pós-condições}: o que deve ser verdade após (efeitos e retornos).
  \item \textbf{Invariantes}: propriedades que não podem ser violadas (ex.: saldo nunca negativo).
\end{itemize}

\begin{block}{Por que isso é dependabilidade?}
Porque dá \textbf{alvos explícitos} para detecção de \err e contenção antes da \fail.
\end{block}

\column{0.44\textwidth}
\centering
\begin{tikzpicture}[
  box/.style={draw, rounded corners, align=center, inner sep=3mm},
  arr/.style={-Latex, thick},
  node distance=7mm
]
\node[box] (pre)  {Pré\\condições};
\node[box, below=of pre] (op)   {Operação};
\node[box, below=of op]  (post) {Pós\\condições};
\node[box, right=12mm of op] (inv) {Invariantes\\(sempre)};

\draw[arr] (pre) -- (op);
\draw[arr] (op) -- (post);
\draw[arr] (inv) -- (op);
\end{tikzpicture}
\end{columns}

%% [AULA] Exemplo rápido: “transferência bancária” (saldo, atomicidade, idempotência) sem entrar em transações ainda.
\end{frame}

\begin{frame}{Fault, Error, Failure (1 slide e seguimos adiante)}
\begin{description}
  \item[Fault] causa potencial (bug, requisito incompleto, config errada, desgaste, operador).
  \item[Error] parte do estado incorreto (ex.: contador corrompido, ponteiro inválido, cache inconsistente).
  \item[Failure] desvio do serviço frente à \spec (ex.: valor errado, timeout, indisponibilidade).
\end{description}

\begin{block}{Ponto-chave desta aula}
O projeto real gira em torno de: \textbf{onde} o error pode surgir, \textbf{como} detectar, \textbf{como} conter, \textbf{como} recuperar.
\end{block}

%% Nota: a taxonomia “clássica” (Avizienis et al.) fica como leitura; aqui a ênfase é na engenharia do mecanismo.
\end{frame}

% =========================================================
\section{Semântica de falhas: declarar o modelo muda tudo}

\begin{frame}{Falha não é única: classes que mudam a arquitetura}
\begin{center}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Classe} & \textbf{Exemplo de desvio de serviço} \\
\midrule
Crash & componente para de responder \\
Omission & mensagens/ações “somem” (perda) \\
Timing & resposta fora da janela (deadline estourado) \\
Value/Response & responde com valor incorreto \\
Byzantine & comportamento arbitrário/inconsistente \\
\bottomrule
\end{tabular}
\end{center}

\begin{block}{Regra de ouro}
Você não “faz tolerância a falhas” em abstrato: você tolera \textbf{um modelo de falha declarado}.
\end{block}

%% TODO: inserir figura “failure spectrum” (crash -> byzantine) com custo de mitigação crescente.
%% Sugestão de fonte (slides/notes distribuídos): Stanford/CMU distributed systems.
\end{frame}

\begin{frame}{Fail-silent, fail-stop, fail-fast (o vocabulário certo)}
\begin{itemize}
  \item \textbf{Fail-silent}: componente falha ficando “mudo” (sem sinais/saídas erradas).
  \item \textbf{Fail-stop}: além de parar, outros componentes conseguem \textbf{detectar} que ele parou.
  \item \textbf{Fail-fast}: ao detectar inconsistência, aborta rapidamente para evitar propagação de \err.
\end{itemize}

\begin{block}{Conexão com projeto}
Assumir fail-stop quando o sistema é na prática value-failure é uma das raízes de incidentes difíceis (falha “falando coisa errada”).
\end{block}

%% [AULA] Dar exemplo: sensor com “valor congelado” (value failure) vs sensor desconectado (omission/crash).
\end{frame}

% =========================================================
\section{Distribuídos: RPC, retries e o “mito do exactly-once”}

\begin{frame}{RPC: onde a intuição do aluno quebra}
\begin{block}{Problema}
Em RPC (rede + processos), não dá para observar diretamente se o servidor executou a operação quando há falhas de comunicação.
\end{block}

Após um timeout, pode ter acontecido:
\begin{itemize}
  \item não executou,
  \item executou 1 vez (mas a resposta se perdeu),
  \item executou múltiplas vezes (retries),
  \item executou parcialmente (efeitos colaterais).
\end{itemize}

%% [AULA] Base conceitual usada em cursos de distribuídos: Stanford/CMU (semântica de execução e retries).
\end{frame}

\begin{frame}{Semântica de execução: at-least-once vs at-most-once}
\begin{columns}[T,onlytextwidth]
\column{0.56\textwidth}
\begin{tcolorbox}[title=at-least-once,colback=white]
\begin{itemize}
  \item Cliente reenvia até obter resposta.
  \item Pode \textbf{executar múltiplas vezes}.
  \item Exige: \textbf{idempotência} ou \textbf{deduplicação} para operações com efeitos colaterais.
\end{itemize}
\end{tcolorbox}

\column{0.44\textwidth}
\begin{tcolorbox}[title=at-most-once,colback=white]
\begin{itemize}
  \item Evita múltiplas execuções via \textbf{IDs} + \textbf{cache de respostas} / \textbf{tabelas de request}.
  \item Pode falhar por \textbf{omissão} (não executar) sob certas perdas.
  \item Requer \textbf{estado} e \textbf{coleta} (GC) desses registros.
\end{itemize}
\end{tcolorbox}
\end{columns}

\begin{block}{Mensagem}
“Exactly-once” é, em geral, \textbf{uma promessa cara/delicada} e frequentemente substituída por idempotência + dedup + transações/compensação.
\end{block}

%% TALKING POINT: conectar com notas clássicas de distribuídos (Stanford/CMU/MIT).
%% TODO: inserir link no slide de referência de distribuídos (CS244b/15-440/6.033).
\end{frame}

\begin{frame}{Tabela mental: por que o cliente não sabe o que ocorreu}
\small
\centering
\begin{tabular}{p{3.2cm} p{3.0cm} p{5.0cm}}
\toprule
\textbf{Evento de falha} & \textbf{Sintoma} & \textbf{Efeito possível} \\
\midrule
Request perdido & timeout & servidor \textbf{não} executa \\
Response perdida & timeout & servidor executa, cliente \textbf{não sabe} \\
Servidor crash após executar & timeout/erro & efeitos ocorreram, mas estado pode estar incerto \\
Partição de rede & timeouts & retries podem amplificar carga (incidente em cascata) \\
\bottomrule
\end{tabular}

\vspace{0.4em}
\begin{block}{Conseqüência}
Retries são mecanismo de tolerância \textbf{e} uma fonte comum de amplificação de falhas se não houver backoff/jitter e controle de explosão.
\end{block}

%% [AULA] Discuta “retry storm/thundering herd” e por que “timeout curto” pode piorar outage.
\end{frame}

\begin{frame}[fragile]{Idempotência: a alavanca mais importante (exemplo simples)}
\begin{lstlisting}[language=Python]
# Operacao NAO idempotente: "debitar" duas vezes = prejuizo
def debit(account_id, amount):
    balance[account_id] -= amount

# Operacao idempotente por chave (idempotency key):
# repetir a requisicao nao muda o efeito final.
def debit_idempotent(account_id, amount, req_id):
    if req_id in processed:        # deduplicacao
        return processed[req_id]   # replay da resposta
    balance[account_id] -= amount
    processed[req_id] = "OK"
    return "OK"
\end{lstlisting}

%% TALKING POINT: Onde guardar processed? (cache vs log durável) -> conecta com transações/recovery.
%% TALKING POINT: Qual o horizonte de dedup? (janela) -> conecta com GC e custo.
\end{frame}

% =========================================================
\section{Contenção: “onde” um erro pode se espalhar}

\begin{frame}{Fault Containment: reduzir o “blast radius”}
\begin{block}{Ideia}
Uma arquitetura tolerante a falhas delimita \textbf{regiões de contenção}: onde um \err pode existir sem virar \fail sistêmica.
\end{block}

\begin{itemize}
  \item Contenção é tão importante quanto recuperação:
    \begin{itemize}
      \item impede corrupção de estado global,
      \item evita cascatas (um módulo derrubando outros),
      \item facilita diagnóstico (localiza causa).
    \end{itemize}
  \item Em software: contenção aparece como \textbf{fronteiras}:
    \begin{itemize}
      \item processo, container, VM, domínio de privilégio, partição de barramento, sandbox.
    \end{itemize}
\end{itemize}

%% TODO: inserir figura “camadas de contenção” (processo->container->VM) e um exemplo de falha propagando sem barreira.
%% Sugestão: materiais de fault management (JPL) para linguagem de contenção/isolamento.
\end{frame}

\begin{frame}{Barreiras clássicas: detectar $\rightarrow$ conter $\rightarrow$ recuperar}
\centering
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[>=Stealth, node distance=2.1cm]
  \node[draw, rounded corners, align=center, minimum width=3.2cm, minimum height=1cm] (fault) {Fault\\(causa)};
  \node[draw, rounded corners, align=center, minimum width=3.2cm, minimum height=1cm, right=of fault] (error) {Error\\(estado)};
  \node[draw, rounded corners, align=center, minimum width=3.2cm, minimum height=1cm, right=of error] (failure) {Failure\\(serviço)};

  \draw[->, thick] (fault) -- (error);
  \draw[->, thick] (error) -- (failure);

  \node[draw, rounded corners, fill=blue!7, align=center, below=0.9cm of error, minimum width=10.0cm]
    (bar) {\textbf{Barreiras}\\
    detecção (checks/timeouts) \quad|\quad contenção (isolamento) \quad|\quad recuperação (restart/rollback)};
  \draw[->, dashed] (bar.north) -- (error.south);
\end{tikzpicture}
}

%% [AULA] Enfatizar: detectar “fault” é difícil; detectar “error” (violação de invariantes) é viável.
\end{frame}

\begin{frame}{End-to-end argument (por que checks na borda importam)}
\begin{block}{Princípio (intuição)}
Algumas propriedades só podem ser garantidas \textbf{de ponta a ponta} na aplicação (ex.: integridade real do dado),
então checks internos (rede/armazenamento) ajudam, mas \textbf{não substituem} o check end-to-end.
\end{block}

\begin{itemize}
  \item Exemplo: checksum em cada hop vs checksum final no payload.
  \item Em dependabilidade: isso define \textbf{onde} colocar detecção para impedir \err$\rightarrow$\fail.
\end{itemize}

%% TODO: inserir figura “end-to-end checksum” em pipeline de rede/armazenamento.
%% Sugestão de leitura clássica (Saltzer/Reed/Clark e discussões posteriores): use como referência histórica.
\end{frame}

% =========================================================
\section{Detecção e diagnosabilidade: projetar para encontrar o problema}

\begin{frame}{Detecção prática: checks que pegam erros cedo}
\begin{itemize}
  \item \textbf{Checks semânticos}: range checks, sanity checks, contratos, invariantes.
  \item \textbf{Checks estruturais}: CRC/checksum, paridade, ECC (onde aplicável).
  \item \textbf{Checks temporais}: timeouts, deadlines, heartbeats.
  \item \textbf{Checks por redundância}: dual execution, comparação, votação (quando necessário).
\end{itemize}

\begin{block}{Escolha de engenharia}
Checks bons são aqueles que:
\begin{itemize}
  \item detectam cedo,
  \item têm baixa taxa de falso positivo,
  \item e são verificáveis/testáveis.
\end{itemize}
\end{block}

%% [AULA] “Detecção” sem ação (conter/recuperar) vira alarme inútil.
\end{frame}

\begin{frame}{Diagnosabilidade: sem telemetria, MTTR explode (sem entrar em métricas)}
\begin{itemize}
  \item Logs estruturados e correlacionáveis (ex.: \textbf{request-id}).
  \item Tracing distribuído (quando há microserviços).
  \item “Black box vs white box”: o que você mede precisa apoiar hipótese causal.
  \item Preserve evidência: dumps, snapshots, ring buffers, post-mortem.
\end{itemize}

\begin{block}{Mensagem}
Dependabilidade em software não é só “rodar sem falhar”: é \textbf{falhar de forma diagnosticável}.
\end{block}

%% [AULA] Exemplificar: “timeout genérico” vs “timeout com contexto + dependência + payload”.
%% NOTE: conceitos de SLO/alerting entram na Aula 2.
\end{frame}

% =========================================================
\section{Recuperação: restart, rollback, transações e compensação}

\begin{frame}{Recuperação: quatro estratégias (com trade-offs)}
\begin{enumerate}
  \item \textbf{Restart} (reboot/restart de processo): simples, mas pode perder estado.
  \item \textbf{Rollback} (checkpoint + voltar): requer pontos consistentes.
  \item \textbf{Transação} (atomicidade/durabilidade): evita estados parciais, mas custa.
  \item \textbf{Compensação} (sagas): desfaz efeitos em sistemas distribuídos quando transação global é inviável.
\end{enumerate}

\begin{block}{Ponto crítico}
A estratégia depende de:
\textbf{(i)} semântica do serviço, \textbf{(ii)} custo de estado inconsistente, \textbf{(iii)} latência aceitável.
\end{block}

%% [AULA] Conectar com o exemplo de RPC: retry + efeitos colaterais -> precisa idempotência ou transação/compensação.
\end{frame}

\begin{frame}{Transações: o que você quer evitar (estado parcial)}
\begin{itemize}
  \item Problema: falha no meio de uma sequência deixa o sistema em estado “meio aplicado”.
  \item Abordagens:
  \begin{itemize}
    \item \textbf{Write-ahead logging} (log durável antes do commit),
    \item \textbf{two-phase commit} (quando aplicável; caro e frágil sob partições),
    \item \textbf{sagas/compensações} em arquiteturas modernas.
  \end{itemize}
\end{itemize}

%% TODO: inserir diagrama simples de estados: BEGIN -> (APPLY) -> COMMIT / ABORT + recuperação.
%% [AULA] Não aprofundar 2PC aqui; se quiser, deixe como leitura em distribuídos/bancos.
\end{frame}

\begin{frame}{Recuperação e contenção andam juntas (senão vira cascata)}
\begin{itemize}
  \item Se um serviço A falha e B faz retry agressivo:
    \begin{itemize}
      \item B aumenta carga em A,
      \item A degrada mais,
      \item A derruba dependências (cascata).
    \end{itemize}
  \item Mitigações típicas:
    \begin{itemize}
      \item backoff/jitter, rate limiting, circuit breaker, filas.
    \end{itemize}
\end{itemize}

%% NOTE: padrões de SRE/microservices aparecem no deck 2; aqui a mensagem é “recovery sem contenção amplifica falhas”.
%% [AULA] Excelente para perguntar: “onde colocar limite de retry?” (cliente? gateway? service mesh?).
\end{frame}

% =========================================================
\section{Estudos de caso (1 técnico + 1 aeroespacial) sem invadir safety/security}

\begin{frame}{Caso 1 (software/ops): Knight Capital (2012) como falha de mudança + contenção}
\begin{itemize}
  \item Contexto: mudança em software de trading; ativação de código/feature em produção.
  \item Efeitos: emissão de ordens inesperadas em alta escala em minutos.
  \item Pontos de engenharia (dependability):
    \begin{itemize}
      \item controle de rollout/configuração,
      \item isolamento e limites de dano (circuitos, rate limits),
      \item observabilidade e “kill switch”.
    \end{itemize}
\end{itemize}

%% TODO: inserir linha do tempo (minutos) e diagrama “deploy -> comportamento -> mitigação”.
%% Sugestão de fonte primária: documentos/registros regulatórios (SEC) sobre o incidente e controles exigidos.
\end{frame}

\begin{frame}{Caso 2 (integração e suposições): Ariane 5 (1996) como falha de envelope}
\begin{itemize}
  \item Reuso de software + hipótese inválida fora do envelope operacional.
  \item Uma exceção em software se propagou para perda de orientação e perda do veículo.
\end{itemize}

\begin{block}{Lição focada (Aula 1)}
\textbf{Semântica de falha + contenção:} quando um subsistema crítico falha, ele deve falhar de forma \textbf{contida} (não virar “saída plausível porém errada” para o controlador).
\end{block}

%% TODO: inserir figura simples “subsystem -> controller” com setas e ponto de contenção.
%% Fonte clássica: relatório de investigação do Ariane 5 (documento público).
\end{frame}

% =========================================================
\section{Exercícios (nível engenharia) e fechamento}

\begin{frame}{Exercícios (1/3): semântica de falhas e especificação}
\begin{enumerate}
  \item Uma API de pagamento tem \spec: “debitar no máximo 1 vez por pedido”.
    \begin{itemize}
      \item Que semântica de execução você precisa?
      \item Qual o mecanismo mínimo (idempotency key / dedup / transação)?
    \end{itemize}
  \item Um sistema de controle tem deadline de 10ms.
    \begin{itemize}
      \item Timing failure é \fail? Por quê?
      \item Proponha 2 checks (temporal e semântico).
    \end{itemize}
\end{enumerate}

%% [AULA] Forçar os alunos a escrever a “frase de especificação” antes de escolher mecanismo.
\end{frame}

\begin{frame}{Exercícios (2/3): contenção e recuperação}
\begin{enumerate}
  \item Identifique 3 fronteiras de contenção possíveis em um sistema IoT:
    (processo, container, MCU+MPU, gateway, cloud).
    Para cada uma, diga: \textbf{o que ela contém} e \textbf{o que não contém}.
  \item Proponha uma estratégia de recuperação para:
    \begin{itemize}
      \item (a) deadlock de firmware (restart),
      \item (b) corrupção de estado (rollback/checkpoint),
      \item (c) efeitos distribuídos (compensação).
    \end{itemize}
\end{enumerate}

%% [AULA] Pedir que identifiquem “efeitos colaterais” e “estado durável” explicitamente.
\end{frame}

\begin{frame}{Exercícios (3/3): armadilhas clássicas}
\begin{enumerate}
  \item Por que retries podem derrubar um sistema já degradado?
  \item O que significa “cobertura de detecção” (coverage) e por que importa?
  \item Dê um exemplo de “causa comum” que derrota redundância em software (mesma config/mesmo bug).
\end{enumerate}

%% NOTE: cálculo de disponibilidade/confiabilidade fica para Aula 2.
%% NOTE: safety/security/resiliência e riscos/ameaças entram na Aula 3.
\end{frame}

\begin{frame}{Resumo da Aula 1 (sem sobrepor com Aula 2/3)}
\begin{itemize}
  \item Falha é desvio do \textbf{serviço} frente à \textbf{especificação}.
  \item Semântica de falhas e de execução (RPC) define escolhas: idempotência, dedup, timeouts e retries.
  \item Arquitetura tolerante a falhas = \textbf{detectar} cedo, \textbf{conter} dano, \textbf{recuperar} com estratégia apropriada.
  \item Projetar para \textbf{diagnosticar} é parte da dependabilidade (sem isso, o reparo vira “arte”).
\end{itemize}

\begin{block}{Gancho}
Na Aula 2, vamos quantificar (modelos/métricas) e compor sistemas; depois, na Aula 3, ampliamos para safety/security/resiliência.
\end{block}
\end{frame}

\begin{frame}[allowframebreaks]{Referências abertas (seleção para este deck)}
\footnotesize
\begin{itemize}
  \item Avizienis, Laprie, Randell, Landwehr. \textit{Basic Concepts and Taxonomy of Dependable and Secure Computing}. IEEE TDSC, 2004.\\
  \url{https://www.landwehr.org/2004-aviz-laprie-randell.pdf}

  \item Stanford (CS244b / Distributed Systems). Notas sobre falhas, RPC e semântica de execução (materiais abertos variam por edição).\\
  %% TODO: substituir pelo link exato que você preferir da edição/ano usada.
  %% Exemplo (notas intro): https://www.scs.stanford.edu/17au-cs244b/notes/intro-print.pdf

  \item CMU (15-440 / Distributed Systems). Materiais de RPC, timeouts e semânticas (at-least/at-most once).\\
  %% TODO: inserir link exato do semestre.
  %% Exemplo: https://www.cs.cmu.edu/~dga/15-440/S14/lectures/

  \item MIT (6.033 / Computer Systems Engineering). Leituras/lectures sobre RPC, falhas parciais e trade-offs de semântica.\\
  %% TODO: inserir link exato do semestre.
  %% Exemplo (MIT OCW 6.033): https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/

  \item JPL/NASA (fault management). Linguagem útil sobre contenção/isolamento e estratégias de fault management.\\
  %% TODO: inserir o PDF específico escolhido (há várias versões/palestras).
  %% Exemplo (JPL presentation): https://trs.jpl.nasa.gov/bitstream/handle/2014/45469/13-0440.pdf

  \item Knight Capital (2012). Documentos regulatórios/relatórios (SEC) sobre controles e falhas de tecnologia.\\
  %% TODO: inserir a referência primária que você adotar (press release / order / report).
\end{itemize}
\end{frame}

\end{document}